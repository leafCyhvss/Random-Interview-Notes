## Eureka
是的，`Eureka Server` 和 `Eureka Client` 是两个不同的组件，但它们都是 Spring Cloud Eureka 的一部分，用于服务发现和注册。下面是这两个组件的简要概述：

1. **Eureka Server**：
   - 它是服务注册中心。其他服务（通常是微服务）在启动时会向 Eureka Server 注册自己，告诉 Eureka 我们的服务在哪里、运行在什么端口、以及其他一些元数据。
   - Eureka Server 会周期性地接收来自所有注册服务的心跳以确保服务仍在运行。如果某个服务在一段时间内没有发送心跳，Eureka Server 会认为该服务已经宕机，并从其注册列表中删除该服务。
   - 它允许其他服务来发现注册的服务。当服务 A 需要与服务 B 通信时，服务 A 可以查询 Eureka Server 以找到服务 B 的实例和地址。

2. **Eureka Client**：
   - 它是一个 Java 客户端，用于简化与 Eureka Server 的交互。当你的服务启动并希望注册到 Eureka Server 时，它会使用 Eureka Client 来处理注册的细节。
   - 除了服务注册外，Eureka Client 还提供了一套 API，使应用程序能够发现其他服务的实例。
   - 很多 Spring Cloud 组件（例如 Spring Cloud Ribbon、Spring Cloud Feign 等）在内部都使用 Eureka Client 来发现其他服务。
   
简单来说，你可以把 **Eureka Server** 看作是一个电话簿，而 **Eureka Client** 是向这本电话簿注册和查找电话号码的人。在微服务架构中，每个微服务（作为客户端）会注册自己的地址到 Eureka Server，并使用 Eureka Client 来查询其他服务的地址。
## 断路器
断路器（Circuit Breaker）是一种行为型设计模式，它旨在防止应用程序连续地尝试执行可能会失败的操作。断路器模式是面向服务的架构（例如微服务）中常见的一种模式，用于检测和处理远程服务的故障。

断路器模式的工作原理如下：

在正常操作期间，断路器处于关闭状态，应用程序可以正常调用远程服务。

如果远程服务出现问题（例如超时或返回错误），断路器将进入开启状态。在此状态下，为了防止进一步的故障（例如连续的超时可能导致系统资源耗尽），断路器会**阻止应用程序继续调用远程服务**。这阶段称为**快速失败**，可以减少资源浪费和提高系统的响应能力。

fallback =》empty / default

**在一段时间后，断路器会进入半开状态**，允许一部分请求去尝试调用远程服务。如果这些请求成功，那么断路器会回到关闭状态，应用程序可以再次正常调用远程服务。如果这些请求失败，那么断路器会再次进入开启状态。

## 微服务框架的优点
decouple, modularity
fault-tolerance：(stable)
scalability and elasticity

## 微服务 grpc, rest template, web socket的区别和选用
在成熟的微服务系统中，服务间的通信确实可以通过多种方式进行，包括RPC（远程过程调用）、HTTP/RESTful API、WebSocket以及消息队列。这些通信方式各有特点和适用场景：

### RPC（远程过程调用）Remote Procedure Call

- **定义**：允许程序调用在另一个地址空间（通常是一台远程服务器）上的函数或过程。
- **优点**：能够提供类似本地函数调用的开发体验，适用于需要强调操作语义和方法调用的场景。
- **缺点**：可能隐藏调用的复杂性，如网络延迟和错误处理。
- **使用场景**：通常用于要求高效、紧密、强类型接口的内部服务通信，比如使用gRPC。

### HTTP/RESTful API

- **定义**：基于HTTP协议的接口风格，用于服务之间的数据交互。
- **优点**：通用、跨平台、无状态、可缓存，容易被各种客户端理解和使用。
- **缺点**：可能不如RPC调用高效，因为HTTP协议本身携带更多开销。
- **使用场景**：适用于对外提供的API、公共服务接口或需要广泛兼容性的内部服务通信。

### WebSocket

- **定义**：提供全双工通信渠道，允许数据在客户端和服务器之间双向流动。
- **优点**：实时性强，适用于需要持续、实时通信的场景，如聊天室、游戏等。
- **缺点**：维护状态和连接可能会增加复杂性和资源消耗。
- **使用场景**：当服务需要推送数据到客户端或保持与服务的持续交互时使用。

### 消息队列

- **定义**：允许应用程序或服务间通过交换消息进行通信，通常支持异步消息传递。
- **优点**：提供了强大的解耦和异步处理能力，增强了系统的容错性。
- **缺点**：消息传递模式可能需要更多的设计考量，如消息格式、幂等性、顺序保证等。
- **使用场景**：适用于不需要即时反馈的情况、大量数据处理、以及跨服务工作流。

### 如何取舍

选择哪种通信方式，取决于以下几个因素：

1. **实时性需求**：如果需要实时互动，WebSocket可能更适合。
2. **复杂性和可维护性**：RESTful API通常更简单和通用，但RPC可以提供更紧密的集成和性能优势。
3. **系统架构**：如果已经在大量使用HTTP/RESTful风格，新增服务可能会选择相同风格以保持一致。
4. **解耦需求**：对于需要高度解耦的场景，如微服务之间的事件通知，消息队列可能更合适。
5. **负载类型**：对于高吞吐量的、非实时性的批量数据处理，消息队列提供了很好的缓冲能力。

通常，大型微服务架构会结合使用这些通信方式，根据不同服务的需求和上下文来选择最合适的通信策略。


## 在微服务系统中，如何实现分布式事务

在微服务架构中实现分布式事务相对复杂，因为需要跨多个服务协调一致性。这里有几种常见的实现分布式事务的方法：

### 1. Saga模式

Saga模式是一种处理长期事务的方法。它将**分布式事务拆分为一系列本地事务**，每个本地事务由不同的服务管理。每个事务完成后，会**发布一个事件通过消息队列来触发下一个事务**。

- **补偿事务**: 如果中途出现任何一个步骤失败，将执行一系列补偿事务**compensation transaction**（也称为反向操作或回滚**rollback**）来保持数据的一致性。

- **异步通信**: Saga通常需要异步通信，消息队列如Kafka或RabbitMQ常被用来实现这一点。

### 2. 两阶段提交（Two-Phase Commit, 2PC）

两阶段提交是一种强一致性的分布式事务协议，涉及所有参与的服务在两个阶段（准备阶段和提交/回滚阶段）来协调事务。
**阻塞：**
有参与的服务节点都必须锁定资源并等待协调器的指令。如果某个服务节点在第一阶段没有响应，那么整个系统将被阻塞，直到该节点恢复。在2PC的准备阶段，参与事务的资源会被锁定，直到事务完成（无论是提交还是回滚），这期间资源不能被其他事务访问

- **准备阶段**: 所有服务准备提交事务，并锁定必要的资源。
- **提交/回滚阶段**: 如果所有服务都准备好了，就提交事务；如果任何一个服务没准备好，就回滚事务。

### 3. 最终一致性

这种方法接受在短期内事务不完全一致的现象，但随着时间的推移，各服务通过重试机制和状态同步来达到最终的一致状态。

- **异步流程**: 处理每个事务的服务会最终同步它们的状态，可能通过定时任务或反应堆模式实现。

### 4. TCC（Try-Confirm/Cancel）模式

TCC是两阶段提交的变种，更加灵活，也是在两个阶段来处理分布式事务。
**与2PC区别**：TCC允许各个服务节点在第一阶段（Try阶段）预留资源而不锁定资源，**resource reservation**，各节点可以继续处理其他操作。**预留资源通常不会阻塞其他操作，因为资源并没有实际上的锁定。**

- **Try阶段**: 尝试执行事务，并保留必要资源。
- **Confirm阶段**: 如果所有服务的Try阶段都成功，那么就进入Confirm阶段，提交所有事务。
- **Cancel阶段**: 如果任何一个Try阶段失败，那么进入Cancel阶段，释放所有保留的资源并回滚已执行的操作。

### 实现分布式事务的挑战

- **性能和可用性**: 分布式事务的实现往往对性能有影响，并可能降低系统的整体可用性。
- **复杂性**: 协调和管理分布式事务增加了系统的复杂性。
- **故障处理**: 必须有效处理网络延迟、服务宕机等分布式系统中的故障。

在设计微服务架构时，通常建议尽可能避免分布式事务，而是通过设计可以容忍一定程度不一致的系统来消除需要它们的情况。如果确实需要分布式事务，通常会倾向于使用Saga模式或TCC，因为它们提供了更好的故障恢复能力和对系统性能和可用性的影响相对较小。